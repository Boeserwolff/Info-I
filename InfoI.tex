\documentclass[a4paper,12pt]{article}
\usepackage[top=2cm, bottom=2cm, left=3cm, right=3cm, headsep=0mm, footskip=10mm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}  % Silbentrennung bei Sonderzeichen
\usepackage[utf8]{inputenc} %Umlaute & Co
\usepackage[normalem]{ulem}
\usepackage{mathtools,amsthm,amssymb,amsfonts}
\usepackage{marvosym}
\usepackage{gauss} % Gaussverfahren mit Pfeilen
\usepackage[table,xcdraw]{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{qtree}
\usepackage{csquotes}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage[neverdecrease,defblank]{paralist}   % enumerate, itemize,...
\usepackage[shortlabels]{enumitem}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{bm} %Fette Mathezeichen
\usepackage[onehalfspacing]{setspace}
\usepackage{array}
\usepackage{ifthen}
\usepackage{xparse}
\usepackage{etoolbox} % toolbox of programming tools
\usetikzlibrary{trees,automata,arrows,shapes}
\usetikzlibrary{shapes.geometric}
\newcommand{\warningsign}{\tikz[baseline=-.75ex] \node[shape=regular polygon, regular polygon sides=3, inner sep=0pt, draw, thick] {\textbf{!}};}
\newcommand{\la}{$\langle$}
\newcommand{\ra}{$\rangle$}
%\newcommand{\anm}{$\langle  \rangle$}
%\newcommand{\an}{$\langle$#1$\rangle$}

%TODO: lstdefinelanguage auf DrRacket anpassen 
 
\lstdefinelanguage{Dr}
{morekeywords={one,two,three,four,five,six,seven,eight,
nine,ten,eleven,twelve,o,clock,rock,around,the,tonight},
sensitive=false,
morecomment=[l]{;},
morecomment=[s]{/*}{*/},
morestring=[b]",
}
\lstset{escapeinside={§}{§},}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=Dr,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\begin{document}
\begin{titlepage}
\centering
	{\scshape\Large Eberhard Karls Universität Tübingen \par}
	\vspace{1cm}
	{\scshape\Large \par}
	\vspace{1.5cm}
	{\huge\bfseries Informatik I Vorlesung\par}
	\vspace{2cm}
	{\Large Wintersemester 2016/2017 \par}
	\vfill
	Mitschrieb von \par Julian Wolff

	\vfill

% Bottom of the page
	{\large Aktueller Stand \today\par}
\end{titlepage}
\tableofcontents
\newpage
\section{Scheme: Ausdrücke, Auswertung und Abstraktion}
\subsection{REPL}
\begin{center}
\begin{tabular}{|l|c|}
\hline
Definition&DrRacket\\
\hline
Interaktion&REPL\\
\hline
\end{tabular}
\end{center}

Die Anwendung von Funktionen wird in Scheme \underline{ausschließlich} in \underline{Präfixnotation} durchgeführt:
\begin{center}
\begin{tabular}{|cc|}
\hline
Mathematik & Scheme\\
\hline
44-2 & (-44 2)\\
f(x,y) & (f x y)\\
$\sqrt{81}$ & (sqrt 81)\\
$\lfloor x\rfloor$& (floor x)\\
$9^2 $& (expt 9 2)\\
3! & (! 3)\\
\hline
\end{tabular}\\

Allgemein: $\langle $Funktion$\rangle \langle$ argument$\rangle$)
\end{center}
(+ 402 ) und (odd? 42) sind Beispiele für die \underline{Ausdrücke}, die bei Auswertung einen Wert liefern. (Notation $\rightsquigarrow$) heißt Auswertung/Evaluation/Reduktion.\\
(+ 40 2) $\underset{Eval}{\rightsquigarrow}$ 42\\
(add? 42)$\underset{Eval}{\rightsquigarrow}$ \#f\\
\\
Interaktionsfenster:\\ 
Re$\underset{\text{\large{Loop}}}{\underbracket{\text{ad}   \rightsquigarrow \text{Eval}  \rightsquigarrow \text{Pri} }}$nt      \hfil     REPL
\\
\\
\subsection{Literale}
\uline{Literale} stehen für einen konstanten Wert (auch: \underline{Konstante}) und sind nicht weiter reduzierbar.
\begin{center}\begin{tabular}{ccl}
\underline{Literal} & &\underline{Signatur}\\
\#t \#f & (true, false, Wahrheitswerte) & boolean\\
\enquote{ac} \enquote{x} \enquote{ } & (Zeichenketten) & string\\
0 1904 -42 007 & (ganze Zahlen) & integer\\
0.42 3.1415 -273.15 & (Fließkommazehlen) & real\\
1/2 3/4 -1/10 & (rationale Zahlen) & rational\\
 \includegraphics[width=0.17\textwidth]{frod.jpg}& (Bilder) & image\\
\end{tabular}
\end{center}
\subsection{Zusammengesetzte Ausdrücke}
Auswertung \underline{zusammengesetzte Ausdrücke} (composite expression) in mehreren Schritten (Steps), "von innen nach außen" , bis keine weitere Reduktion möglich ist:\\
(+(+20 20)(+ 1 1)) $ \rightsquigarrow$ (+ 40 (+ 1 1))  $ \rightsquigarrow$ (+ 40 2)  $ \rightsquigarrow$ 42\\
\\
\underline{Beispiel:}\\
$0.7+(\frac{1}{2}/0.25)-(0.6/0.3)=0.7$\\
\\
\warningsign\underline{Achtung:} Scheme rundet bei Arithmetik mit Fließkommazahlen (interne Darstellung nicht präzise). Die Arithmetik mit rationalen Zahlen ist exakt.\\
\subsection{Identifier}
Ein Wert kann an einen \underline{Namen} (identifier) \underline{gebunden} werden, durch(define$ \langle$id$ \rangle \langle$expression$\rangle$)\\
Es erlaubt konsistente Wiederverwendung und dient der Selbstdokumentation von Programmen.\\
\\
\warningsign \uline{Achtung:} Dies ist eine \underline{Spezialform} und kein Ausdruck. Insbesondere besitzt diese Spezialform keinen Wert, sondern einen Effekt: der Name $\langle$id$\rangle$ wird durch den Wert von $\langle $expression$\rangle$ \underline{gebunden}. Namen können in Scheme fast beliebig gewählt werden, solange
\begin{itemize}
\item[$\bullet$]die Zeichen $ () \lbrack \rbrack   \{\} ", '; \# \backslash$ | nicht vorkommen
\item[$\bullet$]der name nicht einem numerischen Literal gleicht
\item[$\bullet$] keinen Whitespaße (Leerzeichen, Tabulatoren, Neuwlines) enthalten sind
\end{itemize}
\uline{Beispiel:} Euro $\rightarrow$ US-\$\\ \\
\warningsign \uline{ Achtung:} Groß-/Kleinschreibung ist in Identifiern \underline{nicht} relevant.\\

\subsection{Lambda-Abstraktion}
Eine \uline{Lambda-Abstraktion} (auch: Funktion, Prozedur) erlaubt die Formulierung von Ausdrücken, in denen mittels \uline{Parametern} von konkreten Werten abstrahiert wird:

(lambda ($ \langle p_1\rangle \langle p_2\rangle...) \langle$expr$\rangle$)  \\
expr ist der Rumpf und enthält Vorkommen der Paramenter $\langle p_i \rangle$. \\
\\

(lambda...) ist eine Spezialform. Der Wert der Lambda-Abstraktion $\#\langle$procedure$\rangle$\\
Die \uline{Anwendung} (auch: Applikation) der Lambda-Abstraktion führt zur Ersetzung aller Vorkommen der Parameter im Rumpf durch die angegebenen konkreten \uline{Argumente:}\\
\\
\begin{tabular}{|l}

(lambda (days)(*days(*155 minutes-in-a-day)) 365)\\
$\overset{!}{\rightsquigarrow}$ (*365 ( 155 minutes-in-a-day))\\
$\rightsquigarrow$ ...\\
$\rightsquigarrow$ 81468000\\
\end{tabular}
\\
\\
\subsection{Kommentare}
In Scheme leitet ein Semikolon einen \uline{Kommentar} ein, der bis zum Zeilenende reicht und von Racket bei der Auswertung ignoriert wird.\\
Prozeduren/Funktionen sollen im Programm eine ein- bis zweizeilige \uline{Kurzbeschreibung} vorangestellt werden. 

\subsection{Signaturen}
Eine \uline{Signatur} prüft, ob ein Name $\langle$id$\rangle$ an einen Wert einer angegebenen Sorte gebunden wird. Signaturverletzungen werden protokolliert.\\
(: $\langle$ id $\rangle$ $\langle $signatur$\rangle$)\\
Bereits eingebundene Signaturen sind:
\begin{itemize}[$\bullet$]
\item natural \quad $\mathbb{N}$
\item ingeger \quad$\mathbb{Z}$
\item rational\quad $\mathbb{Q}$
\item real  \hspace{10mm}$\mathbb{R}$
\item number\quad $\mathbb{C}$
\item boolean
\item string
\item image
\end{itemize}

\warningsign Der Doppelpunkt \enquote{ : } ist eine Spezialform und hat daher keinen Wert, aber einen Effekt: Eine Signaturprüfung wird durchgeführt.

\subsection{Prozedur-Signaturen}
Prozedur-Signaturen spezifizieren Signaturen sowohl für die Parameter $\langle p_1 \rangle,\langle p_2\rangle$, ... als auch für den Ergebniswert der Prozedur:
\begin{lstlisting}[style=customc]
(:§\la§id§\ra§ (§\la§signatur-§$p_1$\ra§ §\la§ signatur-§$p_2$\ra§ ... §$\rightarrow$§ §\la§signatur-ergebnis§\ra))
\end{lstlisting}


Prozedur-Signaturen werden bei \uline{jeder} Anwendung der Funktion $\langle$id$\rangle$ auf Verletzung geprüft.
\subsection{Testfälle}
\uline{Testfälle} dokumentieren das erwartende Ergebnis einer Prozedur für ausgewählte Argumente:
\begin{lstlisting}[style=customc]
(check-expect §\la$\text{e}_1$\ra§ \la$\text{e}_2$\ra)
\end{lstlisting}
%(check-expect $\langle e_1\rangle$ $\langle e_2 \rangle$)\\
Werte den Ausdruck $\langle e_1\rangle$ aus und teste, ob der erhaltene Wert der Erwartung (=Wert des Ausdruck $\langle e_2 \rangle$) entspricht.\\
Einer Prozedurdefinition sollten Testfälle direkt vorangestellt werden.\\
\warningsign   \enquote{check-expect} ist eine Spezialform und hat daher keinen Wert. Eine Testverletztung wird als Effekt protokolliert.
\subsection{Erinnerung}\uline{Konstruktionsanleitung für Prozeduren:}
\begin{itemize}
\item kurzbeschreibung (ein- bis zweizeiliger Kommentar mit Bezug auf PArameternamen und Ergebnis)
\item Signatur (:$\langle$ name $\rangle$ (... $\rightarrow$))
\item Testfälle check-expect/ ceack-within
\item Prozedurgerüst (define $\langle$name$\rangle$ (lambda ($\langle p_1\rangle \langle p_2\rangle $ ))
\item Rumpf programmieren $\langle$rumpf$\rangle$)
\end{itemize}
\newpage
\subsection{Top-Down-Entwurf (Programmieren mit "Wunschdenken")}
Beispiel: Sunset auf Tatooine (SW Episode IV)

Zeichne Szene zu Zeitpunkt t (t=0 ... 100)
\begin{itemize}
\item[(1)] Himmel verfärbt sich von blau (t=0) zu rot (t=100)
\item[(2)] Sonne(n) versinkt (bei t=100 hinter Horizont)
\item [(3)]Luke starrt auf Horizont (bei jeden t)
\end{itemize}
Zeichne Szene von hinten nach vorne:\\
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.7\textwidth]{wunsch.png}
     \caption{Frodo auf dem Weg nach Mord... äh ich meine natürlich Luke auf Tatooine}
\end{figure}

\begin{lstlisting}[style=customc]
;Zeichne Tatooine Sunset zu Zeitpunkt t
(:tatooine (natural -> image))
(define tatooine
    (lambda (t)
        (overlay/pinhole (luke t)
                         (sun t )
                         (sky t ))))

\end{lstlisting}
\newpage
\subsection{Reduktionsregeln für Scheme ($\rightsquigarrow$)}
Fallunterscheidung je nach Ausdruck:\\
\begin{itemize}
\item
\begin{tabular}{lcccccccr}
Literal l (1, $\#t $, "Karotte", ...)&&&&&&&& $[ eval_{1} ] $\\
\end{tabular}\\
 l $\rightsquigarrow$ l (keine Reduktion möglich)
 
\item
\begin{tabular}{lccccccccccccccr}
Identifier $\langle$id$\rangle$  &&&&&&&&&&&&&&&  $[eval_{id}]$\\
\end{tabular} \\
$\langle$id$\rangle\rightsquigarrow$ Wert, an den $\langle$id$\rangle$ gebunden
\item 
\begin{tabular}{lcccccccccccr}
Lambda-Abstraktion &&&&&&&&&&&& [$eval_\lambda$]\\
\end{tabular}\\
(lambda (...)...) $\rightsquigarrow$ (lanmbda (...)...)
\item Applikation (f $e_1 e_2$...)\\
\begin{itemize}
\item f, $e_1$, $e_2$, ... mittels $\rightsquigarrow$, erhalte f',$e_1'$, $e_2'$ ...
\item $\left[
\begin{tabular}{lcr}
Operation auf $e_1', e_2'$...&     Falls f primitive   &                [apply/prim]\\
anwenden & (eingebaute) Operation & \\
&&\\
Argumentwerte $e_1', e_2', ...$ in & falls f' &    [$apply_\lambda$]\\den Rumpf einsetzen, den&Lambda-Abstraktion&\\ Rumpf mittels $\rightsquigarrow$ reduzieren    
\end{tabular}\right]$\\

Wiederhole Anwendung von $\rightsquigarrow$ bis keine Reduktion mehr möglich ist. 
\end{itemize}
\end{itemize}
\uline{Beispiele:}\\\begin{tabular}{c}
\hline
\end{tabular}\\
(+ 40 2)\\
$\underset{eval_{id}}{\rightsquigarrow} (\#\langle$procedure:+$\rangle$ 40 2)\\
$eval_{lit} \cdot 2$\\
$\underset{apply prim}{\rightsquigarrow} 42 $\\
\\\\\\
(sqr 9)
$\underset{eval_{id}}{\rightsquigarrow } (lambda (x) (* x x))$\\
$eval_{lit}$\\
$\underset{apply_\lambda}{\rightsquigarrow}$ ( * 9 9)\\
$\underset{eval_{id}}{\rightsquigarrow}(\#\langle procedure:*\rangle $ 9 9)\\
$eval_{lit *2}$\\
$\underset{apply_{prim}}{\rightsquigarrow } 81$\\
\subsubsection{Einschub: Lexikalische Bindung}
Bezeichnen  (lambda (x) (* x x)) und (lambda (r) (* r r)) die gleiche Funktion?\\
(... 9)$\overset{*}{\rightsquigarrow} 81$\\
$\Rightarrow$ JA! \\
\warningsign Das hat Einfluss auf das korrekte Einsetzten von Argumenten für Parameter ($s.apply_\lambda$).\\
Das \uline{bindende Vorkommen} eines Identifiers $ \langle x\rangle$ im Programmtext kann systematisch bestimmt werden: Suche strikt "von innen nach außen" bis zum ersten\\
(1) (lambda (x) ...)\\
(2) (define x ...)\\
Das ist das Prinzip der \uline{lexikalischen Bindung} (\warningsign Syntaxprüfung in DrRacket)
\subsection{Übliche Notation in der Mathematik: \uline{Fallunterscheidung!}}
maximum $(x_1,x_2)= \left(\begin{array}{c} x_1 \text{ falls } x_1 \geq x_2 \\ x_2\leftarrow \text{sonst} \end{array}\right)$\\
\uline{Tests} (auch \uline{Prädikate}) sind Funktionen, die einen Wert der Signatur boolean liefern. Typische Primitive in Tests:\\
\begin{lstlisting}[style=customc]
(: = (number number -> boolean))
(: < (real real -> boolean))
(: string=? (string string -> boolean))
(: boolean=? (boolean boolean ->boolean))
(: zero? (number -> boolean))
\end{lstlisting}
Weiter: add?, even?, positive?, negative?, ...\\

\subsection{Spezialform Fallunterscheidung (conditional)}

(cond ($\langle t_1 \rangle \langle e_1 \rangle)\\
(\langle t_2 \rangle \langle e_2 \rangle)\\
...\\
(\langle t_n \rangle \langle e_n \rangle)\\
($else  $\langle e_{n+1} \rangle))$ <- optional
\\
Führt die Tests in der Reihenfolge $\langle t_1 \rangle, \langle t_2 \rangle$, ... durch. Sobald $\langle t_i\rangle$ zu \#t auswertet, werte Zweig $\langle e_i\rangle$ aus. $\langle e_i\rangle $ ist das Ergebnis der Fallunterscheidung. Wenn $\langle t_n\rangle$ \#f liefert, dann liefere \\
$\left(\begin{array}{l}\text{Fehlermeldung " cond: alle Tests ergeben }\#f \text{falls kein else- Zweig, sonst}\\ \langle_{n+1}\rangle \end{array}\right)$

Die Signatur \uline{one-of} lässt genau einen der n aufgezählten Werte zu:\\
(one-of $\langle e_1\rangle \langle e_2\rangle$ ... $\langle e_n\rangle$ )
\\
Reduktion von cond [$eval_{cond}$]
\begin{itemize}
\item (cond ( $\langle t_1 \rangle$ $\langle e_1 \rangle$) ($\langle t_2 \rangle$ $\langle e_2 \rangle$ ) ...)
\begin{itemize}
\item[(1)] Reduziere $\langle t_1 \rangle$, erhalte $\langle t'_1 \rangle$
\item[(2)] $\begin{array}{l} \langle e_1 \rangle \text{ falls } \langle t_1 \rangle = \#t\\
(\text{cond } (\langle t_2 \rangle \langle e_2 \rangle)...)
\end{array}$
\end{itemize}
\item (cond (else$\langle e_{n+1} \rangle$ )) $\rightsquigarrow \langle e_{n+1} \rangle$
( $\langle t_1 \rangle$, $\langle e_2 \rangle$, ... sind \uline{nicht} ausgewertet\\
sonst \\
 $\langle e_1 \rangle$ nicht ausgewertet)
\item (cond ) $\rightsquigarrow$ Fehler "cond alle Tests ergeben \#f

\subsection{Binäre Fallentscheidung:}
\begin{tabular}{rcc}

(if  $\langle t_1 \rangle$  $\langle e_2 \rangle$ 	&		  & (cond ( $\langle t_1 \rangle$ \\
$\langle e_3 \rangle$) 								&$\equiv$ &(else  $\langle e_2 \rangle$) \\
$\langle e_1 \rangle$))								&		  & \														 
\end{tabular}
\end{itemize}
\subsection{Zusammengesetzte Daten}
Daten können interessante intere Struktur (\uline{Komponenten}) aufweisen.\\
\uline{Beispiel:} Ein Star Wars Charakter:\\

\begin{tabular}{|c|l|}
\hline
name & "Luke Skywalker"\\
\hline
jedi? & \#f\\
\hline
force & 25\\
\hline
\end{tabular}
\\\\
\uline{Beispiel:}
\begin{lstlisting}[style=customc]
;Ein Charakter (character) besteht aus
; - Name (name)
; - Jedi-Status (jedi?)
; - Staerke der Macht (force)
(define-record-procedures character
	make-charakter
	character?
	( character-name
	  character-jedi?
	  character-force))
	  
(make-character n j f) §$\rightsquigarrow$ §) §$\langle$§)Tabelle§$\rangle$§)) Konstruktion
(charcter-name §$\langle$§Tabelle§$\rangle$§) §$\rightsquigarrow$§) n Selektor (komponenten auslesen)
(character-jedi? §$\langle$§)Tabelle§$\rangle$§)) §$\rightsquigarrow$§) j
(character-force §$\langle$§)Tabelle§$\rangle$§)) §$\rightsquigarrow$§) f
\end{lstlisting}
\subsection{\uline{Records} in Scheme}
Record-Definition legst fest:
\begin{itemize}
\item Record-Signatur (Name)
\item Konstruktor 		(bau aus komponenten einen Record)
\item Prädikat 			(später)
\item Liste von Selektoren (lesen je eine Komponente des Record)
\end{itemize}
(define-record-procedures $\langle t\rangle$        Signaturname\\
	make-$\langle t \rangle$                        ;Konstruktor\\
	$\langle t \rangle$? 							;Prädikat\\
	($\langle t \rangle$-$\langle comp_1 \rangle$   ;Liste der Selektoren\\
	 ...
	 $\langle t \rangle$-$\langle comp_n \rangle$))\\
Liste der Selektoren legt Komponenten (Anzahl, Reihenfolge, Namen) fest.
Signatur des Konstruktors/der Selektoren für Record-Signatur $\langle t \rangle$ mit n Komponenten $\langle comp_1\rangle$ ...  $\langle comp_n\rangle$:\\
(: make $\langle t \rangle$ ($\underset{\text{n Komponentensignaturen}}{\langle t \rangle}$ ... $\langle t_n \rangle$ $\rightarrow \langle t \rangle $))\\

(: $ \langle t \rangle$-$\langle comp_1 \rangle$ ($ \langle t \rangle \rightarrow \langle t_1 \rangle$))\\\\
$\forall$ string n, boolean j, natural f:\\
(character-name (make-character n j f)) $\rightsquigarrow$ n \\
(character-jedi? (make-character n j f)) $\rightsquigarrow$ j \\
(character-force (make-character n j f)) $\rightsquigarrow$ f \\
\\
Aussagen üver die Interaktion von zwei (oder mehr) Funktionen: algebraische \uline{Eigenschaft}.\\

\subsection{Spezialform check-property}
(check-property 
	(for-all(($\langle id_1\rangle \langle signatur_1\rangle$)
			   ...
			   ($\langle id_n\rangle \langle signatur_n\rangle$))
		$\langle expr \rangle$)) expr ist das Prädikat,  das sich auf $\langle id_q\rangle$ ... $\langle id_n\rangle$ bezieht.
		\\
Test erfolgreich, falls $\langle expr \rangle$ für beliebige Bindungen für $\langle id_1 \rangle$ ... $\langle id_n\rangle$ \uline{immer} \#t ergibt.\\

\subsubsection{Interaktion von Konstruktor und Selektor}
(check-property
	(for-all ((n string)
			  (j boolean)
			  (f natural)))
	(string=? (character-name (make-character n j f)) n))\\

\uline{Beispiel:} Die Summe zweier natürlicher Zahlen ist mindestens so groß wie jede dieser Zahlen. \\
$\forall x_1,x_2 \in \mathbb{N}: x_1 +x_2 \geq max(x_1,x_2)$\\
(check-property
	(for-all (($x_1$ natural)\\
			  ($x_2$ natural))\\
	($\geq$(+ $x_1$ $x_2$) (max $x_1$ $x_2$))))\\
	
Konstruktion von Funktionen $\langle f \rangle$, die zusammengesetzte Daten der Signatur $\langle t \rangle$ \uline{konsumiert}.\\
\begin{itemize}
\item Welchen Record-Komponenten $\langle comp_i \rangle$ sind relevant für $\langle f\rangle$?
\item $\Rightarrow$ Schablone:\\
(:$\langle f \rangle$ (... $\langle t \rangle$ ... $\rightarrow$ ...))\\
(define $\langle$ f $\rangle$\\
	(lambda (... r ...)\\
		... ($\langle t\rangle$-$\langle comp_i\rangle$ r)...))\\
(: not (boolean -> boolean))
\end{itemize}
Prozedur $\langle$f$\rangle$, die zusammengetzte Daten der Signatur $\langle$t$\rangle$ konstruiert/produziert.
\begin{itemize}
\item Konstruktoraufruf für $\langle$t$\rangle$ \uline{muss} enthalten sein!
\begin{lstlisting}[style=customc]
(:§$\langle$§f§$\rangle$§ ( ... -> §$\langle$§t§$\rangle$§))
 (define §$\langle$§f§$\rangle$§
  (lambda (...)
    (...(make-§$\langle$§t§$\rangle$§ ...) ...))
\end{lstlisting}
\begin{figure} \Tree [ .lego-character [ .char [ .name ] [ .jedi? ][ .force ] ] [ .figure ] ]
\end{figure}
\end{itemize}
\begin{tabular}{|c|c|}
\hline
&  \\
char & \begin{tabular}{|c|c|}
\hline
name & \\
jedi? & \\
force & \\
\hline
\end{tabular}\\
& \\
\hline
figure & (BILD)\\
\hline
\end{tabular}
\subsection{Längen/Breitengrade}
\begin{tabular}{lc}
Breitengrade (latitude) & Längengrade (longitude) \\
\begin{tikzpicture}
\draw[red,thick] (0, 0)circle(1);
\draw[dashed] (-1, 0) -- (1, 0);
\draw[dashed] (-0.85, 0.5) -- (0.85, 0.5);
\draw[dashed] (-0.85, -0.5) -- (0.85, -0.5);
\draw[dashed] (1.3, 0.5) -- (1.3, 0.5) node[midway] {$+30^\circ$};
\draw[dashed] (1.6, 0) -- (1.6, 0) node[midway] {$0^\circ$};
\draw[dashed] (3, 0) -- (3, 0) node[midway] {Äquator};
\draw[dashed] (1.3, -0.5) -- (1.3, -0.5) node[midway] {$-30^\circ$};
\end{tikzpicture} &
\begin{tikzpicture}
\draw[red,thick] (0, 0)circle(1);
\draw[dashed] (0, -1) -- (0, 1);
\draw[dashed] (0.5, -0.85) -- (0.5, 0.85);
\draw[dashed] (-0.5, 0.85) -- (-0.5, -0.85);
\draw[dashed] (0, -1.3) -- (0, -1.3) node[midway] {$0^\circ$};
\draw[dashed] (0.7, -1.23) -- (0.7, -1.23) node[midway] {$+30^\circ$};
\draw[dashed] (-0.7, -1.23) -- (-0.7, -1.23) node[midway] {$-30^\circ$};
\draw[dashed] (-1.35, 0) -- (-1.35, 0) node[midway] {$-180^\circ$};
\draw[dashed] (1.35, 0) -- (1.35, 0) node[midway] {$+180^\circ$};
\end{tikzpicture}\\	
\end{tabular}
\\
\\
Sei $\langle$p$\rangle$ ein Prädikat mit Signatur ( $\langle$t$\rangle$ $\rightarrow$ boolean).
Eine Signatur
\begin{lstlisting}[style=customc]
(predicate §$\langle$§p§$\rangle$§)
\end{lstlisting}
gilt für jeden Wert x mit Signatur $\langle$t$\rangle$ für den zusätzlich (p$\langle$p$\rangle$ x)$\rightsquigarrow$ \#t gilt. Signatur (predicate $\langle$p$\rangle$) ist damit spezifischer  (restriktiver) als Signatur $\langle$t$\rangle$.

\subsection{Signaturnamen}
Einführung eines neuen Signaturnamens $\langle$new-t$\rangle$ für die Signatur $\langle$t$\rangle$:
\begin{lstlisting}[style=customc]
(define §$\langle$§new-t§$\rangle$§ (signature §$\langle$§t§$\rangle$§))
\end{lstlisting}
\uline{Beispiele:}
\begin{lstlisting}[style=customc]
(define farbe
 (signature (one-of "Karo" "Herz" "Pik" "Kreuz")))
(define latitude
 (signature (predicate latitude?)))
\end{lstlisting}
Übersetze eine Ortsangabe mittels Google Geocoding
API in eine Position auf der Erdkugel:\\
\begin{lstlisting}[style=customc]
(:geocoder (string ->(mixed geocode geocode-))
\end{lstlisting}
Ein geocode besteht aus:\\
\begin{tabular}{ll}                    
 &							\uline{Signatur}\\
 Adresse (address)			&	string\\
 Ortsangabe (loc)			&	location\\
 Nordostecke (northeast)	&	location\\
 Südwestecke (southwest)	&	location\\
 Typ (type) 				&	string\\
 Genauigkeit (accuracy) 	&	string\\
\end{tabular}
\section{Gemischte Daten}
Die Signatur \uline{mixed}
\begin{lstlisting}[style=customc]
(mixed §$\langle t_1 \rangle$§...§$\langle t_n\rangle$§)
\end{lstlisting}
ist gültig für jeden Wert, der mindestens eine Signatur $\langle t_1 \rangle$ ... $\langle t_n\rangle$ erfüllt.\\
Beispiel: Datendefinition:
\begin{itemize}
\item ein Geocode (Signatur geocode)
\item eine Fehlermeldung (Signatur geocode-error)
\end{itemize}
\begin{lstlisting}[style=customc]
(mixed geocode geocode-error)
\end{lstlisting}
Beispiel \begin{lstlisting}[style=customc]
(eingebaute Funktion string -> number)
(: string -> number (string -> mixed number (one-of #f)))
\end{lstlisting}
Das Prädikat \la t\ra? einer Record-Signatur \la t\ra  unterscheidet Werte der Signatur \la t\ra von \uline{allen anderen} Werten:\\
\begin{lstlisting}[style=customc]
(: §\la§t§\ra§? (any -> boolean))
\end{lstlisting}
\begin{tabular}{ll}
Auch: & Prädikate für eingebaute Signaturen.\\
 & number?, complex?, real?, rational?, integer?,\\ 
 & natural?, string?, boolean?
\end{tabular}
Prozeduren, die gemischte Daten der Singatuen \la $t_1$\ra ... \la $t_n $ \ra konsumieren:
\begin{lstlisting}[style=customc]
(: §\la§f§\ra§(()mixed §\la$t_1$\ra§ ... §\la $t_2$\ra§)-> ...))
(define §\la§f§\ra§
 (lambda (x)
  (cond((§\la$t_1$\ra§? x)...)
   ...
   ((§\la$t_n$\ra§? x)...))))
\end{lstlisting}
Mittels \uline{let} lassen sich Werte an \uline{lokale Namen!} binden:
\begin{lstlisting}[style=customc]
(let ((§\la$id_1$\ra§ §\la$e_2$\ra§) ... (§\la$id_n$\la§ §\la$e_n$\ra§)) e)
\end{lstlisting}
Die Ausdrücke \la $e_1$\ra ... \la$e_n$\ra werden parallel ausgewertet. 

$\Rightarrow$ \la $id_1$\ra ... \la$id_n$\ra können in \la e\ra (und \uline{nur dort!}) verwendet werden.

Der Wert des let-Ausdruck ist der Wert von e.
"nur dort": Verwendung nur in in \la e\ra, nicht in den in \la $e_i$\ra!\\
Lokal: Verwendung nicht außerhalb des (let...)\\
\warningsign Sprachlevel "Die Macht der Abstraktion"
\begin{lstlisting}[style=customc]
(let   )§$\equiv$§(lambda ()  )
\end{lstlisting}
 \glqq Syntaktischer Zucker\grqq = Dinge die nett sind aber ersetzt werden können.\\
\begin{lstlisting}[style=customc]
(check-error §\la§e§\ra§ §\la§msg§\ra§)
\end{lstlisting}
erwartet Abbruch mit Fehlermeldung \la msg\ra. Erzwingen des Programmabbruches mittels (violation \la msg\ra)\\
\subsection{Polymorphe Signaturen}
Beobachtung: Manche Prozeduren arbeiten völlig unabhängig von den Signaturen ihrer Argumente:\\
\uline{parametrisch polymorphe Prozeduren} (griechisch: vielgestaltig). Nutze \uline{Signaturvariablen}:\\
Beispiele:
\begin{lstlisting}[style=customc]
;Identitaet
(: id ( %a -> %a))
(define id (lambda (x) x))

;konstante Funktion (ignoriert zweites Argument)
(: const( %a %b -> %a)) "Anstatt %b kann auch any benutzt werden"
(define const
 (lambda (x y) x))
 
;Projektion (ein Argument auswaehlen) 
(: proj ((one-of 1 2) %a %b -> (mixed %a %b)))
(define proj 
 (lambda (i x y)
  (cond ((= i 1) x)
        ((= i 2) y))))         
\end{lstlisting}
Beachte: Parametrisch polymorphe Prozeduren "wissen nichts" über ihre Argumente mit Signatur \%a, \%b, ... und können diese \uline{nur} reproduzieren oder an andere polymorphe Prozeduren weiterreichen.\\
Eine polymorphe Signatur steht für die Signaturen, in denen die Signaturvariablen \uline{konistent} durch konkrete Signaturen ersetzt werden. \\\\
Beispiel:

Wenn eine Prozedur ( \%a number  \%b -> \%a) erfüllt, dann auch 

(string number boolean -> string)

(boolean number natural -> boolean)

(string number string -> string)

(number number number -> number)
\newpage
\subsection{Polymorphe Paare und Listen}
\begin{lstlisting}[style=customc]
; Ein polymorphes Paar (pair) besteht aus
;- erster Komponente (first)
;- zweite Komponente (rest)
; wobei die komponenten jeweils beliebige Werte sind:

(define-record-procedures-parametric pair pair-of
 make-pair
 pair?
 (first
  rest))
\end{lstlisting}


\begin{lstlisting}
(pair-of §\la $t_1$ \ra \la $t_2$ \ra)
\end{lstlisting}
ist eine Signatur für Paare, deren erste und zweite Komponente von der Signatur \la $t_1$\ra bzw. \la $t_2$\ra sind.
\begin{lstlisting}[style=customc]
(: make-pair ( %a %b -> (pair-of %a %b)))
(: first ((pair-of %a %b) -> %a))
(: rest ((pair-of %a %b) -> %b))
\end{lstlisting}
\subsection{Liste}
Eine \uline{Liste} von Werten der Signatur \la t\ra, (list-of \la t\ra), ist entweder
\begin{itemize}
\item leer (Signatur empty-list) oder
\item ein Paar (Signatur pair-of) aus 
\begin{itemize}
\item einem Listenkopf (Signatur \la t \ra) und
\item einer Restliste (Signatur (list-of \la t\ra)))
\end{itemize}
\end{itemize}
\begin{lstlisting}[style=customc]
(define list-of
 (lambda (t)
  (signature (mixed empty-list
                    (pair-of t (list-of t))
                                         ))))
\end{lstlisting}
(list-of \la t\ra). Listen, deren Elemente die Signatur \la t\ra besitzen.\\
Die Signatur empty-list ist bereits in DrRacket vordefiniert. \\Ebenfalls vordefiniert ist:
\begin{itemize}[-]
\item (: empty empty-list)
\item (: empty? (any -> boolean))
\end{itemize}
\subsection{Visualisierung von Listen}
\begin{lstlisting}[style=customc]
(make-pair 1 (make-pair 2 empty))
\end{lstlisting}
\begin{tabular}{lcl}
lightning &
\begin{tabular}{|c|c|}
\hline & 
\\ 
1 & \begin{tabular}{|c|c|}
\hline
2 & empty \\
\hline
\end{tabular}\\ & \\
\hline
\end{tabular} & Notation skaliert schlecht
\end{tabular}
\subsection{Spines (Rückrad)}
\begin{tikzpicture}[->,thick,level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=3cm}]
\node [rectangle,draw] (z){\ \ \ |\ \ \ \ }
	child{node{The phantom menace}edge from parent[red] node[left,xshift=-5]{first}}
	child{node[rectangle,draw] {\ \ \ |\ \ \ \ }
		child{node{Attack of the Clones}edge from parent[red] node[left,xshift=-5]{first}}
		child{node[rectangle,draw,color=black] {\ \ \ |\ \ \ \ }
			child{node{Revenge of the Sith}edge from parent[red] node[left,xshift=-5]{first}}
			child{node{empty}}edge from parent[green] node[left,xshift=30]{rest}}
		edge from parent[green] node[left,xshift=30]{rest}};
\end{tikzpicture}
\\\\\\
prequels+trilogy:\\
\begin{tikzpicture}[->,thick,level distance=1.5cm,
  level 1/.style={sibling distance=9cm},
  level 2/.style={sibling distance=3cm}]
\node [rectangle,draw] (z){\ \ \ |\ \ \ \ }
	child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
		child{node{TPM}}
		child{node[rectangle,draw,color=black]{\ \ \ |\ \ \ \ }
			child{node{AotC}}
			child{node[rectangle,draw,color=black]{\ \ \ |\ \ \ \ }
				child{node{RotS}}
				child{node{empty}}}}edge from parent[blue]}
	child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
		child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
			child{node{ANH}}
			child{node[rectangle,draw,color=black]{\ \ \ |\ \ \ \ }
				child{node{TESB}}
					child{node[rectangle,draw,color=black]{\ \ \ |\ \ \ \ }
					child{node{RotJ}}
					child{node{empty}}}}edge from parent[red]}
		child{node{empty}}}
	;
\end{tikzpicture}


%Warum mache ich diesen Scheiß eigendlich? P.S.: Ich hasse Baumdiagramme 


\newpage

\subsection{Prozeduren über Listen}
Schablonen für gemischte und zusammengesetzte Daten\\
\uline{Beispiel:}
\begin{lstlisting}[style=customc]
(: list-sum ((list-of number) -> number))

(check-expect (list-sum empty) 0)
(check-expect (list-sum (make-pair 40 (make-pair 2 empty))) 42)

(define list-sum
 (lambda (xs)
  (cond ((empty? xs) 0)
        ((pair?  xs) (+ (first xs) (list-sum (rest xs)))))))
\end{lstlisting}
Schablone für Funktion \la f\ra, die Liste xs konsumiert:
\begin{lstlisting}[style=customc]
(: §\la§f§\ra§ ((list-of §\la $t_1$\ra§) -> §\la $t_2$\ra§))
(define §\la§f§\ra§
 (lambda (xs)
  (cond ((empty? xs) ... )
        ((pair?  xs) ... (first xs) ... (§\la§f§\ra§ (rest xs)) ....))))
					    Signatur t_1			signatur t_2
\end{lstlisting}

\section{Neue Sprachebene "Macht der Abstraktion"}
\begin{itemize}
\item Signatur (list-of \%a) eingebaut 
\item Neuer syntaktischer Zucker eingebaut: \\
 (list \la$e_1$\ra \la$e_2$\ra ... \la$e_n$\ra)\\
 $\equiv$\\
 (m-p \la$e_1$\ra
			 (m-p \la$e_2$\ra\\
			 ...\\
			 (m-p \la$e_n$ empty) ..))\\
\item Ausgabeformat für nicht-leere Listen \\
\#\la list \la$e_1$\ra \la$e_2$\ra ... \la$e_n$\ra\ra
\end{itemize}

\subsection{cat}
;Füge Listen xs, xy zusammen (con\uline{cat}enate)\\
Zwei Fälle (xs leer oder nicht-leer)\\
\begin{tabular}{lccc}
1) & $\overset{xs}{empty}$ & $\overset{ys}{y_1 y_2 y_n}$  & $\overset{(cat xs xy)}{y_1 y_2 y_n}$\\
2) &  $x_1 x_2 x_n$  &          $y_1 y_2 y_n$ &				$\underset{(cat (rest xs) ys)}{	\underset{rest xs}{x_1 x_2    x_n}    \underset{ys}{y_1 y_2   y_n}}$
\end{tabular}

\subsection{Bewertungen}
\begin{itemize}
\item Die Länge von xs (hier n) bestimmt die Anzahl der rekursiven Aufrufe.
\item Auf ys werden keine Selektoren angewandt.

\end{itemize}
Spezialform \uline{match} vergleicht einen Wert \la e\ra mit gegebenen \uline{Patterns} \la $\text{pat}_1$\ra \la $\text{pat}_2$\ra, ... \la $\text{pat}_n$. Falls \la $\text{pat}_1$, $1 \leq i \leq n$, das erste Pattern ist, das auf \la e\ra  \uline{matchted}, ist Zweig \la $\text{e}_i$\ra das Ergebnis (ansonsten wird die Aiswertung mit "keiner der Zewige passte") abgegeben.
\begin{lstlisting}[style=customc]
(match §\la§e§\ra§
 (§\la$\text{pat}_1$\ra§ §\la$e_1$\ra§)
 (§\la$\text{pat}_2$\ra§ §\la$e_2$\ra§)
 (§\la$\text{pat}_n$\ra§ §\la$e_n$\ra§))
\end{lstlisting}

\subsection{Pattern Matching für \la $\text{pat}_i$\ra}
\begin{itemize}
\item Literal \la l\ra:\\
	\la e\ra matched, falls \la e\ra$\rightsquigarrow$\la l\ra
\item "Don't care" \_ :\\
	\la e\ra matched immer
\item Variable \la v\ra\\
	\la e\ra matched immer, danach ist \la v\ra an den Wert von \la e\ra n \la $\text{e}_i$\ra gebunden
\item Record-Konstruktor (\la c\ra \la$\text{pat}_{i1}$\ra \la $\text{pat}_{ik}$), $k\geq \emptyset$\\
	\la e\ra matched, wenn es durch (\la c\ra \la $\text{x}_1$\ra   \la $\text{x}_k$\ra) konstruiert wurde und \la$\text{x}_j$\ra auf \la$\text{pat}_{ij}$ matched, $1\leq j \leq k$
\end{itemize}
\warningsign Fall 4 ermöglicht Pattern Matching auf komplex konstuierten Werten.

\subsection{Rekursion über natürliche Zahlen}
Die natürlichen Zaglen (vgl. gemischte Daten).
Eine natüliche Zahl (natural) ist entweder
\begin{itemize}
\item die 0 (zero)
\item die Nachfolger (succ) einer natülichen Zahl
\end{itemize}
$\mathbb{N}$ = \{0, (succ 0), (succ (succ 0)), ...\}\\
Konstuktoren:
\begin{lstlisting}[style=customc]
(: zero natural)
(define zero 0)

(: succ (natural -> natural))
(define succ
 (lambda (n)
   (+ n 1)))
\end{lstlisting}
Bedingte algebraische Eigenschaften (siehe check-property)
$(= $ $\Rightarrow$ \la p\ra \la e\ra)
Nur, wenn \la p\ra $\rightsquigarrow$ \#t, wird der Ausdruck \la e\ra ausgewertet und getestet ob \la e\ra$\rightsquigarrow$\# t.\\
\uline{Beispiel:} Fakultätsfunktion n! $(n\in \mathbb{N}):\\
0!=1\\
n! =n \cdot (n-1)! \equiv ($succ $n)! = ($succ $n)!\cdot n!$
\begin{center}
$3! = 3 \cdot 2!$\\
$	= 3 \cdot (2 \cdot 1!)$\\
$   = 3 \cdot (2 \cdot (1 \cdot 0 !))$\\
$   = 3 \cdot (2 \cdot (1 \cdot 1))$\\
$   = 6$\\
$10!= 3628800$
\end{center}
\begin{lstlisting}[style=customc]
; Berechne n!
(: factorial (natural -> natural))
(define factorial
  (lambda (n)
    (cond ((= n 0) ...
          ((< n 0) (* (factorial (- n 1)) n))))))
\end{lstlisting}
Schablone für Funktionen \la f\ra, die natürliche Zahlen konsumieren.
\begin{lstlisting}[style=customc]
(: §\la§f§\ra§ (natural -> §\la§t§\ra§))
(define §\la§f§\ra§
  (lambda (n)
    (cond ((= n 0) ...)
		  ((> n 0) ... (§\la§f§\ra§ (- n 1) ... )))))
\end{lstlisting}
\uline{Satz:}\\
Eine Funktion, die nach der Schablone für Listen oder natürliche zahlen geschrieben ist, \uline{terminiert immer}. (=liefert immer ein Ergebnis)\\
Reduktion kann durchaus zur Konstruktion von Ausdrücken führen, die zunehmende Größe aufweisen (Für factorial bestimmt das Argument die Größe.)
Wenn möglich, erzeuge Reduktionsprozesse, die \uline{konstanten Platzverbrauch} - unabhängig von Funktionsargumenten -benötigen.
Beobachtung (Assoziativität von *)
\begin{lstlisting}[style=customc]
    (* 10 (* 9 (* 8 (* 7 (* 6 (factorial 5))))))
=   (* (* (* (* (* 10 9) 8) 7) 6) (factorial 5))
    (*         30240              (factorial 5))
\end{lstlisting}
$\Rightarrow$ Multiplikationen können vorgezogen werden.\\

Idee: Führe Multiplikation jeweils sofort aus.
Schleife des Zwischenergebnis (akkumulierendes Argument) durch die Berechnung. Am Ende enthält der Akkumulator das Endergebnis.\\
Berechne 5!:\\
\begin{lstlisting}[style=customc]
(: fac-worker (natural natural -> natural))
\end{lstlisting}
\begin{center}
\begin{tabular}{c|c}
n & acc \\
\hline
5 & 1   \\
4 & 5   \\
3 & 20  \\
2 & 60  \\
1 & 120 \\
0 & 120 \\
\end{tabular}
\end{center}
\begin{lstlisting}[style=customc]
(: fac-worker (natural natural -> natural))

(define fac-worker
  (lambda (n acc)
    (cond ((= n 0) acc)
		  ((> n 0) (fac-worker ( - n 1) (* acc n))))))
\end{lstlisting}
\begin{lstlisting}[style=customc]
; Berechne n! [wrapper]
(: fac (natural -> natural))
(define fac
  (lambda (n)
    (fac-worker n 1)))
    	
\end{lstlisting}
Ein Reduktionsprozess ist \uline{iterativ}, falls seine Größe konstant bleibt.\\
\begin{tabular}{lll}
Damit: & factorial & nicht iterativ \\
 &		fac-worker & iterativ \\
\end{tabular}\\

Wieso ist fac-worker iterativ? Der rekursive Aufruf ersetzt den aktuell reduzierten Ausdruck \uline{vollständig}. Es gibt keinen \uline{Kontext} (umgebenden Ausdruck), der auf das Ergebnis des rekursiven Aufrufs "wartet".\\
Kontext des rekursiven Aufrufes in
\begin{itemize}
\item factorial: (* n $\underset{Hole}{\qed}$)
\item fac-worker: -keiner-
\end{itemize}
Ein Prozeduraufruf ist \uline{endrekursiv} (tail call), wenn er keinen Kontext besitzt.\\
Prozeduren, die nur endrekursive Prozeduraufrufe enthalten, heißen selbst endrekursiv.\\
Endrekursive Prozeduren führen zu iterativen Reduktionen. \\
Beobachtung: Berechnung von (rev (from-to 1 1000)):

\begin{lstlisting}[style=customc]
(rev (from-to 1 1000))

|.....1000 Aufrufe von make-pair....|
(cat (list 1000 999 ... 2) (list 1))
     |                   \
     |                    |______________
     |                                   |
     (cat (list 1000 999 ... 3) (list 2))
     |....999 Aufrufe von make-pair......|
\end{lstlisting}
$\Rightarrow$ Anzahl Aufrufe von make-pair 1000+999+998+...+1 auf einer Liste der Länge n:\\

$\sum_{i=1}^{n} = \frac{1}{2} \cdot n \cdot (n+1)$ \hfil Quadratisch in n\\

\subsubsection{iterative Listenumkehr (backwards)}
Konstruiere iterative Listenumkehr (backwards)\\
Berechnung von (backwards (list 1 2 3)).
\begin{lstlisting}[style=customc]
(: backwars-worker ((list-of %a) (list-of %a) -> (list-of %a)))
\end{lstlisting}
\begin{center}


\begin{tabular}{rl|ll}
&xs & acc& \\
\hline
&(list 1 2 3) & empty& \\
rest &&& (make-pair 1 acc) \\
&(list 2 3) & (list 1)& \\
rest &&& (make-pair 2 acc) \\
&(list 3) & (list 2 1)& \\
rest &&& (make-pair 3 acc) \\
& empty & (list 3 2 1) & \\
\end{tabular}
\end{center}
linear viele Aufrufe von make-pair!\\
\subsection{letrec}
Mit \uline{letrec} lassen sich Werte an \uline{lokale Namen} binden:
\begin{lstlisting}[style=customc]
(letrec ((§\la$id_1$\ra \la e$_1$\ra§)
	...
         (§\la$id_n$\ra \la$e_n$\ra§))
     §\la§e§\ra§)
\end{lstlisting} 
Die Ausdrücke \la$\text{e}_1$\ra...\la e$_n$\ra dürfen selbst auf die Namen \la $\text{id}_1$\ra ... \la$\text{id}_n$\ra beziegen. Den Wert des gesamten letrec-Ausdruck ist der Wert von \la e\ra.
\subsection{Induktive Definitionen}
Konstruktive Definition der natürlichen Zahlen $\mathbb{N}$:\\
\uline{Def.} (Peano-Axiome)\\
\begin{tabular}{ccc}
(P1) & $ 0 \in \mathbb{N}$ & Null \\
(P2) & $\forall n \in \mathbb{N}$:  succ(n)$\in\mathbb{N}$ & Nachfolger \\
(P3) & $\forall n \in \mathbb{N}$:  succ(n)$\neq0$                     &    succ ist \\
(P4) & $ \forall n,m \in \mathbb{N}: succ(m) =succ(n) \Leftarrow m = n$ &  injektiv (erzeugt neue Elemente)\\
\end{tabular}\\
(BILD TAFEL)\\
\begin{tabular}{cl}
($P_5$) & \uline{Induktionsaxiom:}\\
 & Für jede Menge $M\subseteq \mathbb{N}$: \\
 & Falls $0\in M$ und $\forall n : (n \in M \Rightarrow succ(n)\in M)$,\\
 & dann M = $\mathbb{N}$. "$\mathbb{N}$ enthält nicht mehr als 0 und die durch succ () generierten Elemente." \\
 & "Nichts sonst ist in $\mathbb{N}$" \\
\end{tabular}

\subsection{Beweisschema der vollständigen Induktion}
Sei P(n) eine Eigenschaft einer Zahl $n \in \mathbb{N}$ (Prädikat):
\begin{lstlisting}
(: P (natural -> boolean))
\end{lstlisting}
\uline{Ziel:} Zeige $\forall n \in \mathbb{N}: P(n)$\\
Definiere: $M:=\{n \in \mathbb{N}| P(n) \text{ gilt}\} \subseteq \mathbb{N}$ "M enthält alle n, für die P(n) gilt."\\
\subsection{Induktionsaxiom (P5) für M}
\begin{tabular}{l|l|}
Falls \hfil & Falls \hfil \\
$0 \in M$ & P(0) (INDUKTIONSBASIS)\\
und & und \\
$\forall n:(n \in M \Rightarrow succ(n)\in M)$ & $\forall n:(P(n)\Rightarrow P(succ(n)))$ (INDUKTIONSSCHRITT)\\
dann & dann \\
$M=\mathbb{N}$ & $\forall n \in \mathbb{N}:P(n)$
\end{tabular}
\subsubsection{Beispiel}
\begin{tabular}{ll}
1 & =1\\
1+3 & =4\\
1+3+5 & =9\\
1+3+5+7 & = 16\\
\end{tabular}\\
$\underset{\text{Summe der ersten n+1 ungeraden natürlichen Zahlen}}{\sum_{i=0}^{n} (2i+1)} = (n+1)^2 \equiv P(n)$\\

\uline{Zeige:} $\forall n \in \mathbb{N}: P(n)$
\begin{itemize}
\item[(1)] Induktionsbasis P(0)\\
$\sum_{i=0}^{0} (2i+1) = 2\cdot 0 + 1 = 1 = (0+1)? $\checkmark \\
\item[(2)] Induktionsschritt: $\forall n: (P(n) \Rightarrow P (n+1))$\\
$\sum_{i=0}^{n+1} (2i+1) \underset{\sum}{=} \sum_{i=0}^{n} (2i+1) + 2(n+1)+1\\
\underset{P(n)}{=} (n+1)^2 +2n+3\\
= n^2 + 4n +4 \\
= (n+2)^2 \checkmark $\\
\end{itemize}
\subsubsection{Beispiel}
\begin{lstlisting}[style=customc]
(define factorial
  (lambda (k)
      (if (= k 0) 1
        (* k (factorial (- k 1))))))
\end{lstlisting}
$P(n)\equiv$ (factorial n) = \uline{n!} \hfil \uline{X}: Racket-Repräsentation der Zahl X\\

Zeige : $\forall n\in \mathbb{N}: P(n)$
\begin{itemize}
\item[(1)] Induktionsbasis P(0)\\
(factorial 0)
$\rightsquigarrow$((lambda (k) ...) \uline{0})\\
$\rightsquigarrow$ (if (= 0 0) 1 ...)\\
$\rightsquigarrow$ (if \#t 1 ...)\\
$\rightsquigarrow$ 1 = \uline{0!}
\item[(2)] Induktionsschritt \\
$\forall n : (P(n) \Rightarrow P(n+1)):$\\
(factorial \uline{n+1})\\
$\rightsquigarrow$ ((lambda (k) ...) \uline{n+1})\\
$\rightsquigarrow$ (if (= \uline{n+1} 0)... (* ...))\\
$\rightsquigarrow$ (if \#f ... (* ...))\\
$\rightsquigarrow$ (* \uline{n+1} (factorial (- \uline{n+1} 1))) \hfil Annahme: - realisiert Differenz korrekt\\
$\rightsquigarrow$ (* \uline{n+1} (factorial n)) \\
\uline{P(n)} (* \uline{n+1} \uline{n!}) = (\uline{n+1})! \checkmark \hfil Annahme: + realisiert Multiplikation korrekt.
\end{itemize}
\subsubsection{Beispiel}
Jedes f, das sich an die Schablone für Funktionen über natürlichen Zahlen hält, liefert immer ein Ergebnis (terminiert immer).\\
Sei 
\begin{lstlisting}[style=customc]
(: f (natural -> %a ))
\end{lstlisting} 
also definiert durch:
\begin{lstlisting}[style=customc]
(define f
  (lambda (n)
    (if (= n 0)
         basis
         (step (f (- n 1)) n ))))
\end{lstlisting}
\subsubsection{Bemerkung}
\begin{lstlisting}[style=customc]
(: basis %a)
(: step ( %a natural -> %a))       § \text{totale Funktion}§
\end{lstlisting}
Dann gilt:\\
\begin{tabular}{ll}
P(n)$\equiv$ & (f n) terminiert mit Ergebnis \\
& der Signatur \%a
\end{tabular}\\

\uline{Beweis}\\
\begin{itemize}
\item[(1)] Induktionsbasis P(0)\\
(f \uline{0})\\
$\overset{*}{\rightsquigarrow}$ (if (= \uline{0} 0) basis ...)\\
$\rightsquigarrow$ (if \#t basis)\\
$\rightsquigarrow$ basis \checkmark\\
\item[(2)] Induktionsschritt $\forall n:$(P(n) $\Rightarrow$ P(n+1))\\
(f \uline{n+1})\\
$\rightsquigarrow$ (if (= \uline{n+1} 0) ... (step...))\\
$\rightsquigarrow$ (if \#f ... (step ...))\\
$\rightsquigarrow$ (step (f (- \uline{n+1} 1)) \uline{n+1} )\\
$\rightsquigarrow$ (step $\underset{\text{terminiert mit Ergebnis R}}{\text{(f \uline{n})}}$ \uline{n+1})\\
$\overset{P(n)}{\rightsquigarrow}$ (step R \uline{n+1}) terminiert \checkmark\\
\end{itemize}

\subsection{\uline{Def} (Listen)}
Die Menge M* (= Listen mit Elementen aus M, (list-of M)) ist \uline{induktiv} definiert:
\begin{tabular}{ll}
(l1) & empty $\in M*$\\
(l2) & $\forall c \in M, xs \in M*)$: (make-pair x xs ) $\in M$\\
(l3) & Nichts sonst ist in M*
\end{tabular}
\subsection{Schema der Listeninduktion}
Sei P(xs) eine Eigenschaft von Listen über M:
\begin{lstlisting}[style=customc]
(: P ((list-of M) -> boolean))
\end{lstlisting}

Falls $\underset{\text{P(empty)}}{}$\\
und $\underset{\forall x \in M, xs \in M*:\text{(P(xs)} \Rightarrow \text{ P((make-pair x xs)))}}{}$\\

dann $\underset{\forall xs \in M* :\text{P(xs)}}{}$\\

\uline{Beispiel:} Eigenschaften von cat (append).
\begin{lstlisting}[style=customc]
(define cat
  (lambda (xs xs
    (cond ((empty? xs) ys)
          ((pair? xs) (make-pair (first xs)
                                 (cat (rest xs) ys))))))
\end{lstlisting}

\begin{tabular}{lll}
(1) & (cat empty ys) &= ys\\
(2) & (cat xs empty) &= xs\\
(3) & (cat (cat xs ys) zs) &= (cat xs (cat ys zs))\\
    & "(M*, cat, empty) ist ein Monoid" & \\
    & ($\mathbb{N}$, +, 0) &\\
    & ($\mathbb{N}$, +, 1) & \\
    
\end{tabular}\\
\uline{Beweise}
\begin{itemize}
\item[(1)] (cat empty ys) $\overset{*}{\rightsquigarrow}$ ys \checkmark \\
\item[(2)] P(xs) $\equiv$ (cat xs empty) = xs\\

Induktionsbasis P(empty): (cat empty empty) $\overset{(1)}{=}$ empty \checkmark\\
Induktionsschritt $\forall x \in M, xs' \in M*$: (P(xs') $\Rightarrow$ P((make-pair x xs' )))\\
(cat (make-pair x xs') empty)\\
$\overset{*}{\rightsquigarrow}$ (make-pair)   (HIER FEHLT NOCH WAS)\\ %TODO        
$\overset{*}{\rightsquigarrow}$ (make-pair x (cat xs' empty))\\
$\overset{I.V.}{=}$ (make-pair x xs') \\
\item[(3)] P(xs) $\equiv$ (cat (cat xs ys) zs) = (cat xs (cat ys zs))\\
ys, zs $\in M*$ beliebig\\

Induktionsbasis P(empty)
(cat (cat empty ys) zs) \\
$\overset{(1->)}{=}$ (cat ys zs)\\
$\overset{(1<-)}{=}$ (cat empty (cat ys zs)) \checkmark\\

Induktionsschritt $\forall x \in M, xs' \in M*$: (P(xs') $\Rightarrow$ P ((make-pair x xs'))) \\
(cat (cat (make-pair x xs') ys) zs)\\
$\overset{*}{=}$ (cat (make-pair x (cat xs' ys)) zs)\\
$\overset{*}{\rightsquigarrow}$ (make-pair x (cat (cat xs' ys) zs))\\
$\overset{I.V.}{=}$ (make-pair x (cat xs' (cat ys zs)))\\ 
$\overset{*}{\rightsquigarrow}$ (cat (make-pair x xs') (cat ys) zs)) \checkmark \\
\end{itemize}
\uline{Beispiel:} Interaktion von length/cat
\begin{lstlisting}[style=customc]
(define length
  (lambda (xs)
    (cond ((empty? xs) 0)
          ((pair? xs) (+1 (length (rest xs)))))))
\end{lstlisting}
ys $\in$ M* beliebig
P(xs) $\equiv$ (length (cat xs ys)) = (+ (length xs )(length ys))

Indultionsbasis P(empty) \\
(length (cat emtpy) ys)) \\
$\overset{(1)}{=}$ (length ys) \\
$\overset{(+)}{=}$ (+ 0 (length ys)) \checkmark \\

Induktionsschritt $\forall x \in M, xs' \in M*$: (P(xs') $\Rightarrow$ P ((make-pair x xs')))\\
(length (cat (make-pair x xs') ys )) \\
$\overset{*}{\rightsquigarrow}$ (length (make-pair x (cat xs' ys))) \\
$\overset{*}{\rightsquigarrow}$ (+ 1 (length (rest (make-pair x (cat xs' ys))))) \\
$\rightsquigarrow$ (+1 (length (cat xs' ys))) \\
$\overset{I.V.}{=}$ (+1 (+ (length xs') (length ys))) \\
$\overset{(+) Assoziativ}{=}$ (+ (+ 1 (length xs')) (length ys)) \\
$\overset{*}{\rightsquigarrow}$ (+ (length (make-pair $\underset{\text{beliebig}}{\text{x}}$ xs')) (length ys))  \checkmark \\

\subsection{Prozeduren höherer Ordnung (HIGHER-ORDER FUNCTIONS)}
Abstraktion von Funktionsparametern
\begin{lstlisting}[style=customc]
;Extrahiere die Elemente xs, die das Praedikat p? erfuellen

(: filter (( %a -> boolean)(list-of %a) -> (list-of %a)))
(define filter
  (lambda (p? xs)
    (cond ((empty? xs) empty)
          ((pair? xs)(if (p? (first xs))
                         (make-pair (first xs)
                                    (filter p? (rest xs)))
                         (filter p? (rest xs)))))))
\end{lstlisting}
\newpage

Prozeduren höherer Ordnung (Higher-Order Procedures H.O.P)\\
H.O.P. ...
\begin{itemize}
\item[(1)] akzeptieren Prozeduren als Parameter und/oder
\item[(2)] liefern eine Prozedur als Ergebnis.
\end{itemize}
filter ist vom Typ (1)\\
H.O.P. vermeiden Duplizierung von Code und führen zu
\begin{itemize}
\item kompakteren Programmieren
\item verbesserte Lesbarkeit
\item verbesserte Wartbarkeit
\end{itemize}
\subsubsection{Beispiel (map f xs)}
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\draw (4, -2) node {$\rightsquigarrow$ map (f xs) $\rightsquigarrow$};
\draw (7,0) node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{(f $x_1$)}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{(f $x_2$)}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{(f $x_n$)}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\end{tikzpicture}
\begin{lstlisting}[style=customc]
; Wende f auf alle Elemente von xs an
(: map (( %a -> %b)  (list-of %a) -> (list-of %b)))
(define map
  (lambda (f xs)
    (cond ((empty? xs) empty)
          ((pair? xs) (make-pair (f (fist xs)) (map f (rest xs)))))))
\end{lstlisting}
\subsubsection{Hinweis}
Verwende einfache Lambda-Abstraktion direkt als \uline{anonyme} Funktion, wenn eine globale Benennung (via define) nicht gerechtfertigt erscheint (z.B. bei lokaler/einmaliger Benutzung).
\subsubsection{Listenfaltung}
Allgemeinere Transformation von Listen: \uline{Listenfaltung} (\uline{list folding}).\\
Idee: die Listenkonstruktion make-pair und empty werden systematisch ersetzt:\\
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\draw (4, -2) node {$\rightsquigarrow$ (foldr z c xs) $\rightsquigarrow$};
\draw (7,0) node  {c}
child{node{$x_1$}}
child{node{c}
child{node{$x_2$}}
child{node{c}edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{z}edge from parent[solid]}
}};
\end{tikzpicture}

(foldr z c xs) wirkt als Spine Transformer:
\begin{itemize}
\item empty $\rightarrow$ z
\item make-pair $\rightarrow$ c
\item Eingabe: Liste (list-of \%a)
\item Ausgabe im allg. \uline{keine} Liste (etwa \%b)
\end{itemize}
\begin{lstlisting}[style=customc]
;Falte Liste xs bzgl. c und z
(: foldr ( %b (%a %b -> %b) (list-of %a)-> %b))
(define foldr
  (lambda (z c xs)
    (cond ((empty? xs) z)
          ((pair? xs) c (first xs) (foldr z c (rest xs))))))
\end{lstlisting}
\subsubsection{Beispiele (Reduktionen von xs )}
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\draw (4, -2) node {$\rightsquigarrow$ (foldr 0 + xs) $\rightsquigarrow$};
\draw (7,0) node  {+}
child{node{$x_1$}}
child{node{+}
child{node{$x_2$}}
child{node{+}edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{0}edge from parent[solid]}
}};
\draw (-3, -2) node {$\leftarrow$ (foldr 1 * xs) $\leftarrow$};
\draw (-6,0) node  {*}
child{node{$x_1$}}
child{node{*}
child{node{$x_2$}}
child{node{*}edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{1}edge from parent[solid]}
}};
\end{tikzpicture}
\begin{lstlisting}[style=customc]
(: sum ((list-of number) -> number))
(define sum
  (lambda (xs) (foldr 0 + xs)))
\end{lstlisting}
Länge eine Liste durch Listenfaltung:\\
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\draw (4, -2) node {$\rightsquigarrow$ (foldr z c xs) $\rightsquigarrow$};
\draw (7,0) node  {+}
child{node{1}}
child{node{+}
child{node{1}}
child{node{+}edge from parent[densely dashed]
child{node{1}edge from parent[solid]}
child{node{0}edge from parent[solid]}
}};
\end{tikzpicture}\\
Spine-Transformation
\begin{itemize}
\item empty $\rightarrow$ 0
\item (make-pair y ys) $\rightarrow$ (lambda y ys) (+1 ys)
\end{itemize}
\subsection{Universe}
Teachpack universe nutzt H.O.P., um Animationen (=Sequenzen von Szenen/Bildern) zu definieren.
\begin{lstlisting}[style=customc]
(big-bang §\la$init$\ra§
	(an-tick §\la§ tok§\ra§)
	(to-draw §\la§render§\ra§ §\la§w§\ra§ §\la§h§\ra§))
		   
(: §\la§init§\ra§ %a)    	;Startzustand

(: §\la§tock§\ra§ ( %a -> %a))	;Funktion, die neuen aus alten Zustand berechnet, wird 28 Mal/Sekunde aufgerufen 

(: §\la§render§\ra§ ( %a -> image)) ;Funktion, die aus aktuellem Zustand eine Szene berechnet (wird in Fenster mit §\la§w§\ra§ x §\la§h§\ra§ Pixeln angezeigt)

;Bei Schliessen der Animation wird der letzte aktuelle Zustand zurueckgegeben.

\end{lstlisting}
\subsection{Komposition von Funktionen (allgemein)}
\begin{lstlisting}[style=customc]
((compose f g) x) §$\equiv$§ (f (g x))
\end{lstlisting}
Mathematik: (compose f g) $\equiv f \circ g $ "f nach g" $\Rightarrow$ compose \uline{konstruiert} aus f und g eine \uline{neue Funktion} ("Funktionsfabrik")
\begin{lstlisting}[style=customc]
(: compose ((%b -> %c) ( %a -> %b) -> ( %a -> %c)))

(define compose
  (lamda f g)
    (lambda (x)    ;Ergebnis ist eine
      (f (g x))))) ;Funktion (nicht angewandt)
\end{lstlisting}

repeat: n-fache Komposition einer Funktion f mit sich selbst (n-fache Anwendung von f, Exponentiation)
\begin{center}
$f^0 = id$ (Identität id $\equiv$ (lambda (x) x))\\
$f^n = f^{n-1} \circ f$
\end{center}
\begin{lstlisting}[style=customc]
(: repeat (natural (%a-> %a) -> (%a -> %a)))

(define repeat
(lambda (n f)
  (cond ((= n 0) (lambda (x) x))
        ((> n 0) (compose (repeat (- n 1) f) f)))))
        
;Greife auf das n-te Element von xs zu (n>0)
(: nth (natural (list-of %a) -> %a)) 

(define nth
  (lambda (n xs)
    ((compose first (repeat (- n 1) rest)) xs)))        
\end{lstlisting}

\subsection{Currying}
Reduktion von ((add 1) 41)\\\\
$\overset{\text{eval id}}{\rightsquigarrow}$ ((lambda (x)(lambda (y) (+ x y))) 1 41)\\
$\overset{\text{apply }\lambda}{\rightsquigarrow}$ ((lambda (y) (+ 1 y)) 41)\\
$\overset{\text{apply }\lambda}{\rightsquigarrow}$ (+ 1 41) $\rightsquigarrow$ 42\\
\\
\begin{tikzpicture}
\draw (0,0) node {(\%a \%b $\rightarrow$ \%c)};
\draw (0.4,-1.5) node {(\%a $\rightarrow$ (\%b $\rightarrow$ \%c))};
\draw [thick,->,red] (-1,-0.3) -- (-1,-1) node [right,midway] {curry};
\draw [thick,<-,red] (0.6,-0.3) -- (0.6,-1) node [right,midway] {uncurry}; 
\draw [->](2.5,0) -- (7,0) node[above,midway] {Anwendung auf zwei} node [below,midway] {Argumente \%a \%b} node [right] {\%c};
\draw [->](2.5,-1.5) -- (6,-1.5) node[above,midway] {Anwendung auf ein} node [below,midway] {Argument \%a} node [right] {(\%b$\rightarrow$\%c)};
\draw [->](8.2,-1.5) -- (12,-1.5)node[above,midway] {Anwendung auf ein}node [below,midway] {Argument \%b} node [right] {\%c};
\draw (2.5,-2.3) .. controls (2.5,-3) and (6,-3) .. (6,-2.3) node [below,midway] {partielle Applikation};
\draw [thick,blue,->](8,0) -- (12.5,-0.5);
\draw [thick,blue,->](13,-1.5) -- (13.3,-1.1);
\draw (14,-0.5) node {Schönfinkel} node [below] {Isomprphismus};
\end{tikzpicture}
\\
\begin{itemize}
\item Currying (Haskell B. Curry, Moses Schönfinkel)

Anwendung einer Funktion auf ihr erstes Argument liefert eine Funktion der restlichen Argumente.
\item Jede n-stellige Funktion lässt sich in eine alternative curried Variante transformieren, die in n Schritten jeweils nur ein Argument \\konsumiert: \ \ \ \ \ curry (Transformator)\\ Gegenrichtung: uncurry
\end{itemize}
\begin{lstlisting}[style=customc]
(: curry (( %a %b -> %c) -> ( %a ->( %b -> %c))))

(define curry
  (lambda (f)
    (lambda (x)    ;neue
      (lambda (y)  ;Funktion
        (f x y)    ;
      )
    )
  )
)
\end{lstlisting}

\begin{lstlisting}[style=customc]
(: uncurry ((%a -> (%b -> %c)) -> (%a %b -> %c)))

(define uncurry
  (lambda (f)
    (lambda (x y)    
      ((f x) y)     
      )
    )
  )
\end{lstlisting}

\subsection{Erinnerung}
Bestimmung der ersten Ableitung der reellen Funktion f durch Bildung des \uline{Differenzenquotienten}:
(Hier Bild mit x und y achse und schaubild) $\frac{f(x+h)-f(x)}{h}$ Differenzenquotient
											$\lim\limits_{0} \frac{f(x+h)-f(x)}{h}=f'(x)$ Differentialquotient
\begin{itemize}
\item Operator ' (Ableitung) konsumiert funktion f ind produziert f' $\Rightarrow $ ' ist higher-order
\end{itemize}

\subsection{Streams (stream-of \% a)}
\uline{unendliche} Ströme von Elementen $\text{x}_i$ der Signatur \%a.\\
Ein Stream ist ein Paar 
stream head (X1)     stream tail

\tikz \node [rectangle,draw] {$x_1$ | tail} ;
\%a (-> (stream-of \%a))

\subsection{Vergleich}
\begin{tabular} {ll}
(list-of \%a) & (stream.of \%a) \\
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\end{tikzpicture} &
\begin{tikzpicture}
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ $\lambda$  }
child{node{$x_2$}}
child[missing]};
\end{tikzpicture}

\end{tabular}

\subsubsection{Verzögerte Auswertung eines Ausdrucks (delayed evaluation)}
\begin{itemize}
\item \begin{lstlisting}[style=customc]
(: delay ( %a -> (-> %a)))
(delay §\la§e§\ra§) ;Verzoegere die Auswertung des Ausdrucks §\la§e§\ra§ und liefere "Versprechen" (promise) §\la§e§\ra§ bei Bedarf spaeter auswerten zu koennen.
\end{lstlisting}
\warningsign funktioniert nicht:
\begin{lstlisting}[style=customc]
(define delay
  (lambda (e)
    (lambda () e)))
\end{lstlisting}
\uline{Implementation:}
\begin{lstlisting}[style=customc]
(delay §\la§e§\ra§) §$\equiv$§ (lambda ()§\la§e§\ra§)
\end{lstlisting}

\item 
\begin{lstlisting}[style=customc]
(: force ((-> %a) -> %a))
(force §\la§p§\ra§) ;Erzwinge Auswertung des Promise §\la§p§\ra§, liefere den Wert des verzoegerten Ausdrucks
(define force 
  (lambda (p)
    (p)))
\end{lstlisting}
\end{itemize}

\subsection{Sieb des Erastostgenes (Generierung \uline{aller} Primzahlen)}
Stream-Programm (über 2200 Jahre alt):
\begin{itemize}
\item Starte mit dem Stream str der Zahlen 2,3,4,...
\item Die erste Zahl n in str ist eine Primzahl
\item Streiche alle Vielfachen von n im Stream str
\item weiter bei (2)
\end{itemize}
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\\
\\
\uline{2} 3  5  7  9  11 13 15 17 19 21 23 25\\
\\
\uline{2} \uline{3} 5 7 11 13 17 19 23 25\\
\\
\uline{2} \uline{3} \uline{5} 7 11 13 17 19 23\\

\subsection{Binärbäume}
Die Menge der \uline{Binärbäume} T(M) über M ist Induktiv definiert.
\begin{itemize}
\item[(T1)] empty-tree $\in$ T(M)
\item[(T2)] $\forall x \in M$, l,r $\in T(M)$: (make-node l x r) $\in$ T(M)
\item[(T3)] Nichts sonst ist in T(M)
\end{itemize}
Hinweise:
\begin{itemize}
\item Jeder Knoten (make-node) in einem Binärbaum hat zwei \uline{Teilbäume} l und r sowie eine \uline{Markierung} (\uline{Label}) $x \in M$.
\item Vgl. M* und T(M), empty-list und empty-tree, make-pair und make-node.
\end{itemize}

\subsubsection{Visualisierung/Terminologie}
\begin{itemize}
\item empty-tree: \tikz \draw (-0.2,0.2) -- (0.2,0.2) -- (0.2,-0.2) -- (-0.2,-0.2) -- (-0.2,0.2);
\item (make-node l x r):
\begin{tikzpicture}
\draw (0,0) circle [radius=0.2cm];
\draw (-0.1,-0.1) -- (0.1,0.1);
\draw (0.1,-0.1) -- (-0.1,0.1);
\draw (0.2,0) -- (0.6,-0.5);
\draw (0.6,-0.5) -- (0.35,-0.9) -- (0.8,-0.9) -- (0.6,-0.5);
\draw (-0.2,0) -- (-0.6,-0.5);
\draw (-0.6,-0.5) -- (-0.35,-0.9) -- (-0.8,-0.9) -- (-0.6,-0.5);
\draw (-0.6,-0.74) node {l};
\draw (0.6,-0.74) node {r};
\end{tikzpicture}

\item Der Knoten mit Markierung x ist \uline{Wurzel} (root) des Baumes
\item Ein Knoten, der nur leere Teilbäume besitzt, heißt \uline{Blatt} (\uline{leaf}) Alle anderen Knoten sind \uline{innere Knoten} (inner nodes)

\begin{tikzpicture}[thick,level distance=1.2cm]
\node [circle,draw] {Blatt}
					child{node[rectangle,draw]{}}
					child{node[rectangle,draw]{}};					
\draw (5,0) node [circle,draw] {1} child {node[circle,draw] {2} child{node [rectangle,draw]{}}
child{node [rectangle,draw]{}}}
child {node[circle,draw] {3} child{node [rectangle,draw]{}}
child{node [rectangle,draw]{}}};

\draw (7,0) node{innerer Knoten};

\end{tikzpicture}

\end{itemize}

Beispiel für Binärbäume der Menge T($\mathbb{N}$).
\begin{itemize}
\item Baum $t_1$: listenartig (rechtstief)

\begin{tikzpicture}[thick,level distance=1.2cm,level 2/.style={sibling distance=1cm}]
\node [circle,draw] {1}
	child{node[rectangle,draw]{}}
	child{node[circle,draw]{2}
			child{node[rectangle,draw]{}}
			child{node[circle,draw]{3}
					child{node[rectangle,draw]{}}
					child{node[rectangle,draw]{}}}};
\draw (5,0) node {Knoten mit Label 1 ist \uline{Wurzel}};
\draw (5,-1.2) node {Knoten 1,2 sind \uline{innere Knoten}};
\draw (5,-2.4) node {Knoten 3 ist \uline{Blatt} };	
\end{tikzpicture}
\item Baum $t_2$: balanciert

\begin{tikzpicture}[thick,level distance=1.2cm,level 2/.style={sibling distance=1cm}]
\node [circle,draw] {1}
child{node[circle,draw] {2}
child{node[rectangle,draw]{}}
child{node[rectangle,draw]{}}}
child{node[circle,draw] {3}
child{node[rectangle,draw]{}}
child{node[rectangle,draw]{}}};
					
					
\draw (5,0) node {Knoten 1 ist \uline{Wurzel} und \uline{innerer Knoten}};
\draw (5,-1.2) node {Knoten 2,3 sind Blätter};	
\end{tikzpicture}
\end{itemize}
(Binär-)Bäume haben zahllose Anwendungen:
\begin{itemize}
\item Suchbäume (schneller Zugriff, z.B. in Datenbanksystemen)
\item Datenkompression
\item Darstellung von Programmen/Ausdrücken im Rechner
\item ...
\end{itemize}
Bäume sind \colorbox{red}{DIE} induktive Datenstruktur in der Informatik.

Die \uline{Tiefe} (\uline{depth}) eines Binärbaumes t ist die maximale Länge eines Weges von der Wurzel bis zu einem leeren Teilbaum. Also: 
\begin{lstlisting}
(btree-depth empty-tree)  = 0
(btree-depth t2)          = 2
(btree-depth t3)          = 3
(btree-depth classifier)  = 4
\end{lstlisting}

Schablone (gemischte + zusammengesetzte Daten):
\begin{lstlisting}[style=customc]
(: btree-depth ((btree-of %a) -> natural))

(define btree-depth
  (lambda (t)
    (cond ((empty-tree? t) 0)
          ((node? t) (+ 1 (max (btree-depth (node-left-branch t))
                               (btree-depth (node-right-branch t))
                     ))))))
\end{lstlisting}

\subsubsection{Einschub: Pretty-Printing von Binärbäumen}
Prozedur (pp \la t\ra) erzeugt formatierten String für Binärbaum \la t\ra.
\begin{lstlisting}[style=customc]
(pp §\qed§) = (list "§\qed§")                                          §\hfil§§\hfil§
(pp §\begin{tikzpicture}
\draw (0,0) circle [radius=0.2cm];
\draw (-0.1,-0.1) -- (0.1,0.1);
\draw (0.1,-0.1) -- (-0.1,0.1);
\draw (0.2,0) -- (0.6,-0.5);
\draw (0.6,-0.5) -- (0.35,-0.9) -- (0.8,-0.9) -- (0.6,-0.5);
\draw (-0.2,0) -- (-0.6,-0.5);
\draw (-0.6,-0.5) -- (-0.35,-0.9) -- (-0.8,-0.9) -- (-0.6,-0.5);
\draw (-0.6,-0.74) node {l};
\draw (0.6,-0.74) node {r};
\end{tikzpicture}§) = x
\end{lstlisting}

Idee: Repräsentiere formatierten String als \uline{Liste von Zeichen (String):}
\begin{itemize}
\item[(1)] Nutze (string-append ...) um Zeilen-Strings zu definieren [horizontal]
\item[(2)] Nutze (append... ) um die einzelnen Zeilen zu einer Liste von Zeilen zusammenzusetzen [vertikal]
\end{itemize}
Erst direkt vor der Ausgabe werden die Zeilen-Strings zu einem auszugebendem String zusammengesetzt.
\begin{lstlisting}[style=customc]
(strings-list->string)
\end{lstlisting}
\subsection{Induktion über Binärbäumen}
Sei $P(t)$ eine Eigenschaft von Binärbäumen $t\in T(M)$, also (: P ((btree-of M) -> boolean)).

Falls\\
     P(empty-tree) [Induktionsbeweis]\\
und \\
    $\forall x \in M$,$l\in T(M)$, $r \in T(M)$:\\
    $P(l)\land P(r) \Rightarrow $P((make-node l x r))\\
dann $\forall t \in T(M) P(t).$

\subsubsection{Beispiel:}
Zusammenhang zwischen Größe (btree-size) und Tiefe (btree-depth) eines Binärbaums t:\\
$P(t)\equiv (btree-depth t) \leq (btree-size t) \leq 2^{(btree-depth t)}-1$

\uline{Induktionsbasis P(empty-tree):}\\
(size empty-tree)
$\rightsquigarrow$ 0 $=2^0-1$ $\rightsquigarrow 2^{(depth empty-tree)}-1$ \checkmark

\uline{Induktionsschritt}
$P(l) \land P(r) \rightarrow P((make-node l x r))$\\
 (size (make-node l x r))
$\rightsquigarrow$ (size l) + 1+ 1 (size r)
$\leq 2^{(depth l)}-1+1+2^{(depth r)}-1$\\
$= 2^(depth l)+2^{(swpth r)} -1$\\
$\leq 2 \cdot max ( 2^{(depth l)},2^{(depth r)})-1$\\
$=2\cdot 2^{max((depth l),(depth r))}-1$\\
$=2^{1+max((depth l),(depth r))}-1$\\
$\rightsquigarrow 2^{(depth (make-node l x r))}+1$\\

\subsubsection{Erinnerung}
fold ist Spine-Transformer für Listen xs:\\
\begin{tikzpicture}[thick]
\node [rectangle,draw] {\ \ \ |\ \ \ \ }
child{node{$x_1$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }
child{node{$x_2$}}
child{node[rectangle,draw]{\ \ \ |\ \ \ \ }edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{empty}edge from parent[solid]}
}};
\draw (4, -2) node {$\rightsquigarrow$ (foldr z c xs) $\rightsquigarrow$};
\draw (7,0) node  {c}
child{node{$x_1$}}
child{node{c}
child{node{$x_2$}}
child{node{c}edge from parent[densely dashed]
child{node{$x_n$}edge from parent[solid]}
child{node{z}edge from parent[solid]}
}};
\end{tikzpicture}\\
Wie müsste btree-fold, eine fold-Operation für Binärbäume, verhalten? Tree-Transformer für Bäume t:\\
\begin{tikzpicture}[thick,level distance=1.2cm,level 2/.style={sibling distance=1cm},level 1/.style={sibling distance=2cm}]
\node [circle,draw] {1}
child{node[circle,draw] {2}
child{node[rectangle,draw]{}}
child{node[rectangle,draw]{}}}
child{node[circle,draw] {3}
child{node[rectangle,draw]{}}
child{node[rectangle,draw]{}}};
					
\draw (3.5,-1.2) node {$\rightsquigarrow$ (btree-fold z c t) $\rightsquigarrow$};	
\draw (7.5,0) node {(c . $x_1$ .)}
child{node {(c . $x_2$ .)}
child{node{z}}
child{node{z}}}
child{node {(c . $x_3$ .)}
child{node{z}}
child{node{z}}};
\end{tikzpicture}
\begin{lstlisting}[style=customc]
;Falte Baum bzgl. z und c

(: btree-fold ( %b (%b %a %b -> b)(btree-of %a) -> %b))

(define btree-fold
  (lambda (z c t)
    (cond ((empty-tree? t) z)
          ((node? t)  (c (btree-fold z c (node-left.branch t))
                         (node-label t)
                         (btree-fold z c (node-right-branch t)))))))
\end{lstlisting}
    
\end{document}