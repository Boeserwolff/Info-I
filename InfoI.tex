\documentclass[a4paper,12pt]{article}
\usepackage[top=2cm, bottom=2cm, left=3cm, right=3cm, headsep=0mm, footskip=10mm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}  % Silbentrennung bei Sonderzeichen
\usepackage[utf8]{inputenc} %Umlaute & Co
\usepackage[normalem]{ulem}
\usepackage{mathtools,amsthm,amssymb,amsfonts}
\usepackage{marvosym}
\usepackage{gauss} % Gaussverfahren mit Pfeilen
\usepackage[table,xcdraw]{xcolor}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{csquotes}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage[neverdecrease,defblank]{paralist}   % enumerate, itemize,...
\usepackage[shortlabels]{enumitem}
\usepackage{titlesec}
\usepackage{listings}
\usepackage{bm} %Fette Mathezeichen
\usepackage[onehalfspacing]{setspace}
\usepackage{array}
\usepackage{ifthen}
\usepackage{xparse}
\usepackage{etoolbox} % toolbox of programming tools
\usetikzlibrary{trees,automata,arrows,shapes}
\usetikzlibrary{shapes.geometric}
\newcommand{\warningsign}{\tikz[baseline=-.75ex] \node[shape=regular polygon, regular polygon sides=3, inner sep=0pt, draw, thick] {\textbf{!}};}
 
%TODO: lstdefinelanguage auf DrRacket anpassen 
 
\lstdefinelanguage{Dr}
{morekeywords={one,two,three,four,five,six,seven,eight,
nine,ten,eleven,twelve,o,clock,rock,around,the,tonight},
sensitive=false,
morecomment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]",
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=Dr,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\begin{document}
\begin{titlepage}
\centering
	{\scshape\Large Eberhard Karls Universität Tübingen \par}
	\vspace{1cm}
	{\scshape\Large \par}
	\vspace{1.5cm}
	{\huge\bfseries Informatik I Vorlesung\par}
	\vspace{2cm}
	{\Large Wintersemester 2016/2017 \par}
	\vfill
	Mitschrieb von \par Julian Wolff

	\vfill

% Bottom of the page
	{\large Aktueller Stand \today\par}
\end{titlepage}
\tableofcontents
\newpage
\section{Scheme: Ausdrücke, Auswertung und Abstraktion}
\subsection{REPL}
\begin{center}
\begin{tabular}{|l|c|}
\hline
Definition&DrRacket\\
\hline
Interaktion&REPL\\
\hline
\end{tabular}
\end{center}

Die Anwendung von Funktionen wird in Scheme \underline{ausschließlich} in \underline{Präfixnotation} durchgeführt:
\begin{center}
\begin{tabular}{|cc|}
\hline
Mathematik & Scheme\\
\hline
44-2 & (-44 2)\\
f(x,y) & (f x y)\\
$\sqrt{81}$ & (sqrt 81)\\
$\lfloor x\rfloor$& (floor x)\\
$9^2 $& (expt 9 2)\\
3! & (! 3)\\
\hline
\end{tabular}\\

Allgemein: $\langle $Funktion$\rangle \langle$ argument$\rangle$)
\end{center}
(+ 402 ) und (odd? 42) sind Beispiele für die \underline{Ausdrücke}, die bei Auswertung einen Wert liefern. (Notation $\rightsquigarrow$) heißt Auswertung/Evaluation/Reduktion.\\
(+ 40 2) $\underset{Eval}{\rightsquigarrow}$ 42\\
(add? 42)$\underset{Eval}{\rightsquigarrow}$ \#f\\
\\
Interaktionsfenster:\\ 
Re$\underset{\text{\large{Loop}}}{\underbracket{\text{ad}   \rightsquigarrow \text{Eval}  \rightsquigarrow \text{Pri} }}$nt      \hfil     REPL
\\
\\
\subsection{Literale}
\uline{Literale} stehen für einen konstanten Wert (auch: \underline{Konstante}) und sind nicht weiter reduzierbar.
\begin{center}\begin{tabular}{ccl}
\underline{Literal} & &\underline{Signatur}\\
\#t \#f & (true, false, Wahrheitswerte) & boolean\\
\enquote{ac} \enquote{x} \enquote{ } & (Zeichenketten) & string\\
0 1904 -42 007 & (ganze Zahlen) & integer\\
0.42 3.1415 -273.15 & (Fließkommazehlen) & real\\
1/2 3/4 -1/10 & (rationale Zahlen) & rational\\
 \includegraphics[width=0.17\textwidth]{frod.jpg}& (Bilder) & image\\
\end{tabular}
\end{center}
\subsection{Zusammengesetzte Ausdrücke}
Auswertung \underline{zusammengesetzte Ausdrücke} (composite expression) in mehreren Schritten (Steps), "von innen nach außen" , bis keine weitere Reduktion möglich ist:\\
(+(+20 20)(+ 1 1)) $ \rightsquigarrow$ (+ 40 (+ 1 1))  $ \rightsquigarrow$ (+ 40 2)  $ \rightsquigarrow$ 42\\
\\
\underline{Beispiel:}\\
$0.7+(\frac{1}{2}/0.25)-(0.6/0.3)=0.7$\\
\\
\warningsign\underline{Achtung:} Scheme rundet bei Arithmetik mit Fließkommazahlen (interne Darstellung nicht präzise). Die Arithmetik mit rationalen Zahlen ist exakt.\\
\subsection{Identifier}
Ein Wert kann an einen \underline{Namen} (identifier) \underline{gebunden} werden, durch(define$ \langle$id$ \rangle \langle$expression$\rangle$)\\
Es erlaubt konsistente Wiederverwendung und dient der Selbstdokumentation von Programmen.\\
\\
\warningsign \uline{Achtung:} Dies ist eine \underline{Spezialform} und kein Ausdruck. Insbesondere besitzt diese Spezialform keinen Wert, sondern einen Effekt: der Name $\langle$id$\rangle$ wird durch den Wert von $\langle $expression$\rangle$ \underline{gebunden}. Namen können in Scheme fast beliebig gewählt werden, solange
\begin{itemize}
\item[$\bullet$]die Zeichen $ () \lbrack \rbrack   \{\} ", '; \# \backslash$ | nicht vorkommen
\item[$\bullet$]der name nicht einem numerischen Literal gleicht
\item[$\bullet$] keinen Whitespaße (Leerzeichen, Tabulatoren, Neuwlines) enthalten sind
\end{itemize}
\uline{Beispiel:} Euro $\rightarrow$ US-\$\\ \\
\warningsign \uline{ Achtung:} Groß-/Kleinschreibung ist in Identifiern \underline{nicht} relevant.\\

\subsection{Lambda-Abstraktion}Eine \uline{Lambda-Abstraktion} (auch: Funktion, Prozedur) erlaubt die Formulierung von Ausdrücken, in denen mittels \uline{Parametern} von konkreten Werten abstrahiert wird:

(lambda ($ \langle p_1\rangle \langle p_2\rangle...) \langle$expr$\rangle$)  \\
expr ist der Rumpf und enthält Vorkommen der Paramenter $\langle p_i \rangle$. \\
\\

(lambda...) ist eine Spezialform. Der Wert der Lambda-Abstraktion $\#\langle$procedure$\rangle$\\
Die \uline{Anwendung} (auch: Applikation) der Lambda-Abstraktion führt zur Ersetzung aller Vorkommen der Parameter im Rumpf durch die angegebenen konkreten \uline{Argumente:}\\
\\
\begin{tabular}{|l}

(lambda (days)(*days(*155 minutes-in-a-day)) 365)\\
$\overset{!}{\rightsquigarrow}$ (*365 ( 155 minutes-in-a-day))\\
$\rightsquigarrow$ ...\\
$\rightsquigarrow$ 81468000\\
\end{tabular}
\\
\\
\subsection{Kommentare}
In Scheme leitet ein Semikolon einen \uline{Kommentar} ein, der bis zum Zeilenende reicht und von Racket bei der Auswertung ignoriert wird.\\
Prozeduren/Funktionen sollen im Programm eine ein- bis zweizeilige \uline{Kurzbeschreibung} vorangestellt werden. 

\subsection{Signaturen}
Eine \uline{Signatur} prüft, ob ein Name $\langle$id$\rangle$ an einen Wert einer angegebenen Sorte gebunden wird. Signaturverletzungen werden protokolliert.\\
(: $\langle$ id $\rangle$ $\langle $signatur$\rangle$)\\
Bereits eingebundene Signaturen sind:
\begin{itemize}[$\bullet$]
\item natural \quad $\mathbb{N}$
\item ingeger \quad$\mathbb{Z}$
\item rational\quad $\mathbb{Q}$
\item real  \hspace{10mm}$\mathbb{R}$
\item number\quad $\mathbb{C}$
\item boolean
\item string
\item image
\end{itemize}

\warningsign Der Doppelpunkt \enquote{ : } ist eine Spezialform und hat daher keinen Wert, aber einen Effekt: Eine Signaturprüfung wird durchgeführt.\\

\subsection{Prozedur-Signaturen}
Prozedur-Signaturen spezifizieren Signaturen sowohl für die Parameter $\langle p_1 \rangle,\langle p_2\rangle$, ... als auch für den Ergebniswert der Prozedur:\\
(:$\langle$id$\rangle$($\langle$signatur-$p_1\rangle$ $\langle$signatur-$p_2\rangle$ ... $\rightarrow \langle$signatur-ergebnis$\rangle$))\\

Prozedur-Signaturen werden bei \uline{jeder} Anwendung der Funktion $\langle$id$\rangle$ auf Verletzung geprüft.\\
\subsection{Testfälle}
\uline{Testfälle} dokumentieren das erwartende Ergebnis einer Prozedur für ausgewählte Argumente:\\
(check-expect $\langle e_1\rangle$ $\langle e_2 \rangle$)\\
Werte den Ausdruck $\langle e_1\rangle$ aus und teste, ob der erhaltene Wert der Erwartung (=Wert des Ausdruck $\langle e_2 \rangle$) entspricht.\\
Einer Prozedurdefinition sollten Testfälle direkt vorangestellt werden.\\
\warningsign   \enquote{check-expect} ist eine Spezialform und hat daher keinen Wert. Eine Testverletztung wird als Effekt protokolliert.
\subsection{Erinnerung}\uline{Konstruktionsanleitung für Prozeduren:}\\
\begin{itemize}
\item kurzbeschreibung (ein- bis zweizeiliger Kommentar mit Bezug auf PArameternamen und Ergebnis)
\item Signatur (:$\langle$ name $\rangle$ (... $\rightarrow$))
\item Testfälle check-expect/ ceack-within
\item Prozedurgerüst (define $\langle$name$\rangle$ (lambda ($\langle p_1\rangle \langle p_2\rangle $ ))
\item Rumpf programmieren $\langle$rumpf$\rangle$)
\end{itemize}
\newpage
\subsection{Top-Down-Entwurf (Programmieren mit "Wunschdenken")}
Beispiel: Sunset auf Tatooine (SW Episode IV)

Zeichne Szene zu Zeitpunkt t (t=0 ... 100)
\begin{itemize}
\item[(1)] Himmel verfärbt sich von blau (t=0) zu rot (t=100)
\item[(2)] Sonne(n) versinkt (bei t=100 hinter Horizont)
\item [(3)]Luke starrt auf Horizont (bei jeden t)
\end{itemize}
Zeichne Szene von hinten nach vorne:\\
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.7\textwidth]{wunsch.png}
     \caption{Frodo auf dem Weg nach Mord... äh ich meine natürlich Luke auf Tatooine}
\end{figure}

\begin{lstlisting}[style=customc]
;Zeichne Tatooine Sunset zu Zeitpunkt t
(:tatooine (natural -> image))
(define tatooine
    (lambda (t)
        (overlay/pinhole (luke t)
                         (sun t )
                         (sky t ))))

\end{lstlisting}
\newpage
\subsection{Reduktionsregeln für Scheme ($\rightsquigarrow$)}
Fallunterscheidung je nach Ausdruck:\\
\begin{itemize}
\item
\begin{tabular}{lcccccccr}
Literal l (1, $\#t $, "Karotte", ...)&&&&&&&& $[ eval_{1} ] $\\
\end{tabular}\\
 l $\rightsquigarrow$ l (keine Reduktion möglich)
 
\item
\begin{tabular}{lccccccccccccccr}
Identifier $\langle$id$\rangle$  &&&&&&&&&&&&&&&  $[eval_{id}]$\\
\end{tabular} \\
$\langle$id$\rangle\rightsquigarrow$ Wert, an den $\langle$id$\rangle$ gebunden
\item 
\begin{tabular}{lcccccccccccr}
Lambda-Abstraktion &&&&&&&&&&&& [$eval_\lambda$]\\
\end{tabular}\\
(lambda (...)...) $\rightsquigarrow$ (lanmbda (...)...)
\item Applikation (f $e_1 e_2$...)\\
\begin{itemize}
\item f, $e_1$, $e_2$, ... mittels $\rightsquigarrow$, erhalte f',$e_1'$, $e_2'$ ...
\item $\left[
\begin{tabular}{lcr}
Operation auf $e_1', e_2'$...&     Falls f primitive   &                [apply/prim]\\
anwenden & (eingebaute) Operation & \\
&&\\
Argumentwerte $e_1', e_2', ...$ in & falls f' &    [$apply_\lambda$]\\den Rumpf einsetzen, den&Lambda-Abstraktion&\\ Rumpf mittels $\rightsquigarrow$ reduzieren    
\end{tabular}\right]$\\

Wiederhole Anwendung von $\rightsquigarrow$ bis keine Reduktion mehr möglich ist. 
\end{itemize}
\end{itemize}
\uline{Beispiele:}\\\begin{tabular}{c}
\hline
\end{tabular}\\
(+ 40 2)\\
$\underset{eval_{id}}{\rightsquigarrow} (\#\langle$procedure:+$\rangle$ 40 2)\\
$eval_{lit} \cdot 2$\\
$\underset{apply prim}{\rightsquigarrow} 42 $\\
\\\\\\
(sqr 9)
$\underset{eval_{id}}{\rightsquigarrow } (lambda (x) (* x x))$\\
$eval_{lit}$\\
$\underset{apply_\lambda}{\rightsquigarrow}$ ( * 9 9)\\
$\underset{eval_{id}}{\rightsquigarrow}(\#\langle procedure:*\rangle $ 9 9)\\
$eval_{lit *2}$\\
$\underset{apply_{prim}}{\rightsquigarrow } 81$\\

\end{document}
